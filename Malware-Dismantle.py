#!/usr/bin/env python
import os, sys, datetime, hashlib, requests, json


#CONFIGURATION###########################################################################################################################
stringPatterns = ["http", "www", "POST", "proc", "exec", "script", "password", ".com", ".net", ".edu", ".", "/", "\\"] #default patterns are "http", "www", "POST", "proc", "exec", "script", "password", ".com", ".net", ".edu" (probably unnecessary for normal use, but I defend an academic institution, ".", "/", "\\"); should be re-ordered so that '.' and '/' appear at the end - potentially write function to automate?
#   consider: popular commands? other things common to phishing/botnets/malicious macros?
#   isolate for IPs, file extensions, directory navigation  -  but not annoying html junk
stringRadius = 3
#########################################################################################################################################


targetHelp = ""
arg1 = ""
arg2 = ""
if(len(sys.argv) > 1):
    targetHelp = sys.argv[1]
    if(len(sys.argv) > 2):
        arg1 = sys.argv[len(sys.argv) - 1]
        if(len(sys.argv) > 3):
            arg2 = sys.argv[len(sys.argv) - 2]
else:
    targetHelp = raw_input("Enter the location of the target file: ")
fileName, fileExtension = os.path.splitext(targetHelp)
logFile = "MD-"+fileName+".log"


def main():
    targetFile = targetHelp

#    print("Updating ClamAV signatures")
#    os.system("sudo freshclam")
    print("Skipping sutomatic update of clamAV signatures")

    print("\nResults will be saved in "+logFile+"\n")

    currTime = str(datetime.datetime.now())
    os.system("echo \""+currTime+"\n\" | tee -a "+logFile)

    #unzip
    if((arg1 == "-z") or (arg2 == "-z")):
	print("  ___                                               ___\n / _ \\                     ___                     / _ \\\n| (_) |====\\         _,.--'\\  `--.._         /====| (_) |\n \\___/     \\\\     ,*'       \".      `*.     //     \\___/\n            \\====/            \\        \\====/\n                /              \".       \\\n               f                 \\___    1\n               | |`-._           f  /1   |\n               |  \\   `-._       | / |   |\n               l   `-.__,-`      l/__j   ;\n                \\_                    \\_/\n  ___       /=====\\                   /=====\\       ___\n / _ \     //      \\                 /      \\\\     / _ \\\n| (_) |====/       |   _    _    _   |       \\====| (_) |\n \\___/             l  | |  | |  | |  ;             \\___/\n                    `--  --- ---  --\"")
        print("File will temporarily exist on THIS system")
        cont = raw_input("\tAre you certain that static analysis here is safe? (y/n): ")
        if('y' in cont):
            unzipOutput = os.popen("unzip -P infected "+targetFile).read()
            try:
                targetFile = unzipOutput.split("inflating: ",1)[1]
            except:
                targetFile = unzipOutput.split("extracting: ",1)[1]
            targetFile = targetFile[:-3]
            targetFile = targetFile.rstrip()
        else:
            sys.exit()
        os.system("chmod -x "+targetFile)

    #VT API /file/scan
    os.system("echo \"\nSubmitting file to VirusTotal\" | tee -a "+logFile)
    url = "https://www.virustotal.com/vtapi/v2/file/scan"
    internetConnect = False
    try:
        _ = requests.get(url, timeout=5)
        internetConnect = True
        with open("../../VT-api.key") as k:
            myKey = k.readline().strip()
        k.close()
        params = {"apikey": myKey}
        files = {"file": (targetFile, open(targetFile, "rb"))}
        response = requests.post(url, files=files, params=params)
        vtSub = response.json()
        vtCheck = vtSub["permalink"]
        vtLink = str(vtCheck)
        os.system("echo \"VirusTotal submission link: "+vtLink+"\n\" | tee -a "+logFile)
    except requests.ConnectionError:
        os.system("echo \"This machine appears to be air-gapped. File will not be submitted to VirusTotal\n\" | tee -a "+logFile)

    #hash
    gen_hash = ""
    with open(targetFile, "rb") as f:
        bytes = f.read() # read entire file as bytes
        gen_hash = hashlib.md5(bytes).hexdigest()
    f.close()
    os.system("echo \"MD5: "+gen_hash+"\n\" | tee -a "+logFile)

    #file
    execDispTarget("file", targetFile)

    #strings isolate
    stringLog = "strings-"+fileName+".log"
    os.system("strings -a "+targetFile+" > "+stringLog)

    #clamAV scan
    execDispTarget("clamscan --allmatch --detect-pua=yes --phishing-sigs=yes --phishing-scan-urls=yes --alert-macros=yes", targetFile)

    #binwalk - make optional suggestion
    executable = 'n'
    if((arg1 == "-e") or (arg2 == "-e")):
        executable = 'y'
    else:
        executable = raw_input("Could there be embedded executable code? (y/n): ")
    if('y' in executable):
        execDispTarget("binwalk", targetFile)
    else:
        os.system("echo \"\n\" | tee -a "+logFile)

    #remove unzipped
    if((arg1 == "-z") or (arg2 == "-z")):
        os.system("echo \"REMOVING MALICIOUS FILE\n\" |tee -a "+logFile)
        os.system("rm "+targetFile)

    #string summary - designed to give IPs to block, websites to investigate, or files to scan for; not made for automated analysis
    os.system("echo \"summary of important strings:\" | tee -a "+logFile)
    #reOrganizeStrings()
    noString = 0
    stringsFile = open(stringLog, 'r')
    logAppend = open(logFile, 'a')
    for line in stringsFile:
        line = line.rstrip()
        if(analyzeString(line) == 1):
            logAppend.write(line)
            print(line)
            noString = 1
    logAppend.close()
    stringsFile.close()
    if(noString == 0):
        os.system("echo \"(No important strings detected)\" | tee -a "+logFile)
    os.system("echo \"All strings available in "+stringLog+"\n\" | tee -a "+logFile)

    #VT API /file/report
    if(internetConnect):
        url = "https://www.virustotal.com/vtapi/v2/file/report"
        params = {"apikey": myKey, "resource": gen_hash}
        response = requests.get(url, params=params)
        responseStr = str(response.json())
        num = responseStr.index("u'positives': ") #need to get json working
        answer = "VirusTotal engines detecting this file: "+responseStr[num + 14]
        if(responseStr[num+15] != ','):
            answer = answer+responseStr[num+15]
        os.system("echo "+answer+" | tee -a "+logFile) #still needs to go to log
        os.system("echo \"Full VirusTotal report can be viewed at: "+vtLink+"\" | tee -a "+logFile)
#        print(responseStr)
        #webbrowser option


def execDispTarget(cmdStr, targetFile):
    os.system("echo \""+cmdStr+":\" | tee -a "+logFile+"; "+cmdStr+' '+targetFile+" | tee -a "+logFile+"; echo \"\n\" | tee -a "+logFile)


def analyzeString(string): #designed to give IPs to block, websites to investigate, or files to scan for; not made fore automated analysis
    for pattern in stringPatterns:
        locations = []
        if((pattern == ".") and ("." in string)): #IP or file extension
            locations = [i for i, ltr in enumerate(string) if ltr == "."]
            for point in locations:
                #check for filename and extension
                before = string[point - stringRadius : point]
                after = string[point + 1 : point + stringRadius + 1]
                if(before.isalnum() and after.isalpha()): #after is alpha, appears to have file name; restrict to only one '.' per space (or atleast string of pure characters)?
                    return 1
                #check for IP
                before = string[point - 1 : point]
                after = string[point + 1 : point + 1 + 1]
                if(isInt(before) and isInt(after)): #appears to be IP address; restrict to no "version" anywhere before
                    previous = string[:point]
                    if(not("version" in previous)):
                        return 1
        elif(((pattern == "/") and ("/" in string)) or ((pattern == "\\") and ("\\" in string))): #file path, only alphanumeric before and after (at stringRadius chars), do not includ if '=' anywhere before
            if(pattern == "/"):
                locations = [i for i, ltr in enumerate(string) if ltr == "/"]
            if(pattern == "\\"):
                locations = [i for i, ltr in enumerate(string) if ltr == "\\"]
            for point in locations:
                before = string[point - stringRadius : point]
                after = string[point + 1 : point + stringRadius + 1
                if(before.isalnum() and after.isalnum()):
                    previous = string[:point]
                    if(not("=" in previous)):
                        return 1
        else:
            if(pattern in string):
                return 1

    return 0


def isInt(string):
    try:
        val = int(string)
        return 1
    except ValueError:
        return 0



main()
